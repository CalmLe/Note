# 刷题笔记 



## 2021年3月

### 3月4日
#### 题目：leetcode[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

 题目链接：[1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/two-sum/)

个人思路: 这个题目的话可以用朴素做法写，两层循环但是这样时间复杂度就为O(n2)，但是这题可以用哈希的思路去写,这样的话时间复杂度为O(n), **key为数的值，value为数字对应的下标，通过unordered_map中的find方法（该方法的时间复杂度为0(1)）**,这样的话就只要套一层循环了，然后时间复杂度就为O(n),这里要用**unordered_map**的键是无序的，而本题不需要这个键是有序的

 **方法： 哈希**
 ```c++
 class Solution {
 public:
     vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>mymap;
        vector<int> res;
        for (int i = 0; i < nums.size(); i++){
     //若没有找到这个键的话，就返回end()
            auto itor = mymap.find(target - nums[i]);
            if(itor != mymap.end()) {
     //呜呜呜，这个写成itor.second直接error了寄
                res.push_back(itor->second);
                res.push_back(i);
                break;
            }
            else {
                mymap[nums[i]] = i;
            }
        }
        return res;
     }
 };
 ```

犯的错误：不能用itor.second 只能用itor ->second



#### 题目：leetcode[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

题目链接: [454. 四数相加 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/4sum-ii/)

个人思路：



#### 题目：leetcode[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

题目链接：[704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-search/)

个人思路： 题目已经是升序排序了，而且还没有重复的元素（要是有重复元素做起来就很复杂了），所以很容易就想到了用二分查找来做，时间复杂度为O(logn)

**方法：二分**

``` c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = -1, r = nums.size();
        while(l + 1 < r) {
            int mid = (r - l >> 1) + l;
            if(nums[mid] < target) l = mid;
            else r = mid;
        }
    //这里别忘记了特殊判定
        if(r < nums.size() && nums[r] == target) return r;
        return -1;
    }
};
```

犯的错误： 这里容易忽略特判 r < nums.size(); 这也是up主五点七边所说的需要特判情况

#### 题目：leetcode[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

题目链接：[242. 有效的字母异位词 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-anagram/)

个人思路：统计每个字母出现的次数，将字母映射成数组的小标a-z映射成1-26这样大大节省了空间同时在时间上也很快，这样只要扫一遍就知道了，时间复杂度为O(n),数组是一种最简单的哈希表

**方法：数组哈希**(最优)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
      //之前出现了一个小问题， 这里的数组忘记初始化了
        int arr[30] = {0};
        for(int i = 0; i < s.size(); i++) arr[s[i] - 'a' + 1]++;
        for(int i = 0; i < t.size(); i++) arr[t[i] - 'a' + 1]--;
        for (int i = 1; i <= 26; i++) {
            if(arr[i] != 0) return false;
        }
        return true;
    }
};
```

错误原因：arr数组忘记初始化了，所以一开始的值不一定全是0所以会出现错误

**方法：sort排序**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        if(s.size() != t.size()) return false;
        if(s == t) return true;
        return false;
    }
};
```

**方法：unordered_map**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<int,int> mymap;
        for(int i = 0; i < s.size(); i++) mymap[s[i] - 'a' + 1]++;
        for(int i = 0; i < t.size(); i++) mymap[t[i] - 'a' + 1]--;
        for(auto item : mymap) {
            if(item.second != 0) return false;
        }
        return true;
    }
};
```



## 2021年4月 