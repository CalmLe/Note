# 刷题笔记 



## 2021年3月

### 3月4日
#### 题目1：leetcode[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

 题目链接：[1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/two-sum/)

个人思路: 这个题目的话可以用朴素做法写，两层循环但是这样时间复杂度就为O(n2)，但是这题可以用哈希的思路去写,这样的话时间复杂度为O(n), **key为数的值，value为数字对应的下标，通过unordered_map中的find方法（该方法的时间复杂度为0(1)）**,这样的话就只要套一层循环了，然后时间复杂度就为O(n),这里要用**unordered_map**的键是无序的，而本题不需要这个键是有序的

 **方法： 哈希**
 ```c++
 class Solution {
 public:
     vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>mymap;
        vector<int> res;
        for (int i = 0; i < nums.size(); i++){
     //若没有找到这个键的话，就返回end()
            auto itor = mymap.find(target - nums[i]);
            if(itor != mymap.end()) {
     //呜呜呜，这个写成itor.second直接error了寄
                res.push_back(itor->second);
                res.push_back(i);
                break;
            }
            else {
                mymap[nums[i]] = i;
            }
        }
        return res;
     }
 };
 ```

犯的错误：不能用itor.second 只能用itor ->second



#### 题目2：leetcode[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

题目链接: [454. 四数相加 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/4sum-ii/)

个人思路：这题是一个经典的哈希题目，其实这个题目跟两数之和大同小异，这个四数之和的话就是把两个数组的和看成一个整体然后统计次数，然后再把另外两个数组的和扫一遍查找, 时间复杂度0(n2)

**方法 ： unordered_map哈希**

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> AB; // AB key为a跟b的和， value为出现的次数
        int cnt = 0;
        for(auto a: nums1) {
            for (auto b: nums2) {
                AB[a + b]++;
            }
        }
        for (auto c : nums3) {
            for(auto d : nums4) {
                if(AB.find(-c-d) != AB.end()) cnt += AB[-c-d];
            }
        }
        return cnt;
    }
};
```







#### 题目3：leetcode[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

题目链接：[704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-search/)

个人思路： 题目已经是升序排序了，而且还没有重复的元素（要是有重复元素做起来就很复杂了），所以很容易就想到了用二分查找来做，时间复杂度为O(logn)

**方法：二分**

``` c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = -1, r = nums.size();
        while(l + 1 < r) {
            int mid = (r - l >> 1) + l;
            if(nums[mid] < target) l = mid;
            else r = mid;
        }
    //这里别忘记了特殊判定
        if(r < nums.size() && nums[r] == target) return r;
        return -1;
    }
};
```

犯的错误： 这里容易忽略特判 r < nums.size(); 这也是up主五点七边所说的需要特判情况

#### 题目4：leetcode[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

题目链接：[242. 有效的字母异位词 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-anagram/)

个人思路：统计每个字母出现的次数，将字母映射成数组的小标a-z映射成1-26这样大大节省了空间同时在时间上也很快，这样只要扫一遍就知道了，时间复杂度为O(n),数组是一种最简单的哈希表

**方法：数组哈希（最优）**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
      //之前出现了一个小问题， 这里的数组忘记初始化了
        int arr[30] = {0};
        for(int i = 0; i < s.size(); i++) arr[s[i] - 'a' + 1]++;
        for(int i = 0; i < t.size(); i++) arr[t[i] - 'a' + 1]--;
        for (int i = 1; i <= 26; i++) {
            if(arr[i] != 0) return false;
        }
        return true;
    }
};
```

错误原因：arr数组忘记初始化了，所以一开始的值不一定全是0所以会出现错误

**方法：sort排序**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        if(s.size() != t.size()) return false;
        if(s == t) return true;
        return false;
    }
};
```

**方法：unordered_map**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<int,int> mymap;
        for(int i = 0; i < s.size(); i++) mymap[s[i] - 'a' + 1]++;
        for(int i = 0; i < t.size(); i++) mymap[t[i] - 'a' + 1]--;
        for(auto item : mymap) {
            if(item.second != 0) return false;
        }
        return true;
    }
};
```



#### 题目5：leetcode[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

题目链接：[383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ransom-note/)

个人思路： 由题目分析得ransomNote是magazine的子集；也就是说统计magazine各个字母的次数，然后减去ransomNote各个字母的次数，最好再扫一遍，若是出现负数了，说明不满足，否则满足

方法 ： **数组哈希**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
           int arr[30] = {0};
           for (int i = 0; i < magazine.size(); i++) {
               arr[magazine[i] - 'a' + 1]++;
           }
           for (int i = 0; i < ransomNote.size(); i++) {
               arr[ransomNote[i] - 'a' + 1]--;
               if(arr[ransomNote[i] - 'a' + 1] < 0) return false;
           }
           for (int i = 1; i <= 26; i++) {
               if(arr[i] < 0) return false;
           }
           return true;
    }
};
```



#### 题目6：leetcode349. 两个数组的交集

题目链接：[349. 两个数组的交集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

个人思路： 用bool数组模拟，数组的下标表示数字，下标对应的值表示这个数 是否存在，默认为0，对原数组扫一遍，若存在则为1，然后再把另外一个数组扫一遍，若这个数存或者之前没有被存储在答案数组里则把这个数存起来然后再标记为0，以防储存重复的，这样的作法适合元素不大的情况

**方法：数组哈希**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        bool arr[1010] = {0};
        vector<int>res;
        for(int i = 0; i < nums1.size(); i++) {
            arr[nums1[i]] = 1;
        }
        for(int i = 0; i < nums2.size(); i++) {
            if(arr[nums2[i]]) {
                arr[nums2[i]] = 0;
                res.push_back(nums2[i]);
            }
        }
        return res;
    }
};
```



**方法：集合**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> res;
        //这样的用法要学会哦，直接用构造函数
        unordered_set<int> set1(nums1.begin(), nums1.end()); //把数组nums1的值放到set中(无序的)
        for (int i = 0; i < nums2.size(); i++) {
            if(set1.find(nums2[i]) != set1.end()) res.insert(nums2[i]);
        }
        //这样的用法要学会哦，直接用构造函数
        return vector<int>(res.begin(),res.end());
    }
};
```



### 3月5日

#### 题目1：luogu：P1182 数列分段 Section II

题目链接：[P1182 数列分段 Section II - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1182)

个人思路：

**方法： 贪心 + 二分**

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 1e5 + 10;
int arr[maxn];
int N,M,cnt;
LL res, l = -0x7fffffff,r;
inline int read() {
    char c = getchar();
    int s = 0, w = 1;
    for(;!isdigit(c); c = getchar()) if(c == '-') w = -1;
    for(;isdigit(c); c = getchar()) s = (s << 3) + (s << 1) + (c ^ 48);
    return s * w;
}
inline int max(LL a, LL b) {
    return (a >= b) ? a : b;
}
inline bool check(int x) {
    //  小细节这里得从1开始而不是0;
    res = 0,cnt = 1;
    for (int i = 0; i < N; i++) {
        if(res + arr[i] <= x) res += arr[i];
        else res = arr[i], cnt++;
    }
    return cnt > M;
}
inline int find() {
    l = l - 1, r = r + 1;
    while(l + 1 < r) {
        int mid = (r - l >> 1) + l;
        if(check(mid)) l = mid;
        else r = mid;
    }
    return r;
}
int main(void) {
    N = read(), M = read();
    for (int i = 0; i < N; i++) {
        arr[i] = read();
        l = max(l, arr[i]);
        r += arr[i];
    }
    printf("%d",find());
    return 0;
}
```

#### 题目2：luogu：P3853 [TJOI2007]路标设置

题目链接:[P3853 [TJOI2007\]路标设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3853)

个人思路:

**方法： 二分 + 模拟**

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e4 + 10;
int stone[maxn];
int L, N, M, l, r;
inline int read() {
    char c = getchar();
    int s = 0, w = 1;
    for(;!isdigit(c); c = getchar()) if(c == '-') w = -1;
    for(;isdigit(c); c = getchar()) s = (s << 3) + (s << 1) + (c ^ 48);
    return s * w;
}
inline bool check(int x) {
    int amt = 0, now = 0;
    //模拟跳石头,now这个变量表示当前这个人所在的位置
    for (int i = 1; i <= N + 1; i++) {
        if(stone[i] - stone[now] < x) amt++;
        else now = i;
    }
    return amt <= M;
}
int find() {
    l = 0 - 1, r = 1e9 + 1;
    while(l + 1 < r) {
        int mid = (r - l >> 1) + l;
        if(check(mid)) l = mid;
        else r = mid;
    }
    return l;
}
int main(void) {
    L = read(), N = read(), M = read();
    for (int i = 1; i <= N; i++) stone[i] = read();
    //这一步很重要
    stone[N + 1] = L;
    printf("%d\n", find());
    return 0;
}
```



## 2021年4月 