# oop特性



## 运算符重载 ##

> #### 运算符重载
>
> 类似于函数的多态，但是这个并不是**函数重载或者函数多态**，**运算符重载是多态的一种形式**，编译器通过操作数的数目和类型决定使用哪种符号的定义，重载运算符让代码看起来更加自然
>
> > ##### 运算符重载的例子
> >
> > c++中很多运算符都被重载过举个例子：我们用的cout `<<`，是重载了`<<`运算符
> >
> > **cout**是一个**ostream类**的对象，它有一个成员运算符函数operator<<,平时使用时我们能够接受不同类型的数据，如整型、浮点型、字符串甚至指针，这是因为标准库的设计者们早已经为我们定制了iostream::operator<<对于各种C++**基本数据类型的重载版本**
> >
> > > ##### 注意：iostream库定义了以下三个标准流对象
> > >
> > > * `cin `：表示标准输入(standard input)的ostream类对象。cin使我们可以从设备读入数据。
> > > * `cout`：表示标准输出(standard output)的ostream类对象。cout使我们可以向设备输出或者写数据。
> > > * `cerr`：表示标准错误(standard error)的ostream类对象。cerr是导出程序错误消息的地方，它只能允许向屏幕设备写数据
> >
> > ```c++
> > #include <bits/stdc++.h>
> > using namespace std;
> > int main(void) {
> >     cout.operator << (12345);
> >     cout.operator << (endl);
> >     return 0;
> > }
> > ```
> >
> > 
>
> ####  运算符重载的**限制**:
>
> * 必须是存在的运算符，不能虚构一个运算符号
>
> * 使用运算符不能违反运算符原来运算符的规则，已经不能破坏优先级
>
> * 重载后的运算符必须至少有一个操作位数是用户自定义的，这将防止用户为标准类型重在运算符
>
> * **某些运算符是不能重载的**      （例如：`sizeof运算符`，`.成员运算符`，`作用域解析运算符::`
>
> * 大多数运算符都可以通过成员函数或者非成员函数的进行重载，但是下面四种运算符**只能通过成员函数进行承载**（常见的就是这四种）
>
>     `=` 赋值运算符
>
>     `()`函数调用运算符
>
>     `[]`下标运算符
>
>     `->`通过指针访问类成员的运算符
>
> ####  重载运算符的两种方法：
>
> * 通过成员函数进行重载
>
>     ```c++
>     class Time{
>     	//省略很多东西
>     	Time operator+ (const Time& t) constl  //member version
>     };
>     ```
>
> * 通过非成员函数进行重载(**基本上都要用到友元函数**，因为只有这样才能访问它的私有部分数据)
>
>     ```c++
>     class Time{
>     	//省略很多东西
>         friend Time operator + (const Time& t1, const Time& t2);  //友元非成员函数
>     };
>     Time operator + (const Time& t1, const Time& t2) {
>                                                                                                                 
>     }
>     ```
>
> 
>
> > ##### 注意：
> >
> > * 重载运算符函数的参数个数与运算符的操作位数有关，比如若是定义 `&ostream operator << (const T& t1, const T& t2)`，这个若是非成员函数版本则是对的，要是是成员函数版本就错了因为<<接受两个操作对象，这样的话就三个了错误
> > * 非成员函数版本的重载运算符函数所需的**形参数目与运算符使用的操作数相同**；而成员版本所需的参数数目少一个，因为其中一个操作数是被隐式地传递的调用对象
> > * 定义运算符时，必须选择其中一种格式，避免两种格式混用，因为这两种格式都与同一个表达式匹配，**同时定义这两种格式将被视为二义性错误，导致编译错误**



### 1.成员函数运算符重载

> * 通过成员函数进行重载
>
>     ```c++
>     //mytime.h
>     #ifndef MYTIME_H_
>     #define MYTIME_H_
>     #include <iostream>
>                                                                                                                                     
>     class Time{
>         private:
>             int hours;
>             int minutes;
>         public:
>             Time();
>             Time(int h, int m);
>             void AddMin(int m);
>             void Addhr(int h);
>             Time operator+ (const Time& t) const;      //通过成员函数进行重载
>             Time operator- (const Time& t) const;	   //通过成员函数进行重载
>             Time operator* (const double& n) const;	   //通过成员函数进行重载		
>             friend Time operator *(const double& n, const Time& t) {return t * n;} //通过非成员函数进行重载
>             friend std::ostream& operator <<(std::ostream& os, const Time& t);	   //通过非成员函数进行重载
>     };
>                                                                                                                                     
>     #endif
>     ```
>
>     



### 2.非成员函数运算符重载

> * 通过非成员函数进行重载(**基本上都要用到友元函数**，因为只有这样才能访问它的私有部分数据)
>
>     ```c++
>     //mytime.h
>     #ifndef MYTIME_H_
>     #define MYTIME_H_
>     #include <iostream>
>                                                                                                                                     
>     class Time{
>         private:
>             int hours;
>             int minutes;
>         public:
>             Time();
>             Time(int h, int m);
>             void AddMin(int m);
>             void Addhr(int h);
>             Time operator+ (const Time& t) const;      //通过成员函数进行重载
>             Time operator- (const Time& t) const;	   //通过成员函数进行重载
>             Time operator* (const double& n) const;	   //通过成员函数进行重载		
>             friend Time operator *(const double& n, const Time& t) {return t * n;} //通过非成员函数进行重载
>             friend std::ostream& operator <<(std::ostream& os, const Time& t);	   //通过非成员函数进行重载
>     };
>                                                                                                                                     
>     #endif
>     ```
>
>     



## 友元 ##

> `友元`：c++**控制对类私有部分的访问**，通常情况下提供了共有方法唯一的访问途径，但这个有时候不太方便，c++提供了**另一种形式的访问：`友元`**
>
> 友元的分类：
>
> * **友元非成员函数**
> * **友元成员函数**
> * **友元类**



### 1.友元函数 

> `友元函数`：赋予与该类的成员函数相同的访问权限，类的友元函数是**非成员函数**，但是其**访问权限与成员函数相同**
>
> 创建友元函数: 
>
> ```c++
> class Time{
> 	//省略很多东西
> 
> // 1.只有类声明中的原型中才能用friend关键字，除非函数定义也是原型，否则不能在函数定义中使用friend关键字
> 	friend Time operator * (double m, const Time& t);   
> };
> 
> //2.不能在这里使用关键字friend,同时不需要Time::限定符，因为它不属于成员函数   -----------> 我在这里翻过错误呜呜呜
> Time operator * (double m, const Time& t) {
> 
> }
> ```
>
> > **注意事项：**
> >
> > * 只有类声明中的原型中**才能用friend关键字**，除非函数定义也是原型，否则不能在函数定义中使用friend关键字
> > * **不需要 类名::限定符**，因为它不属于成员函数
>
> ### 应用：
>
> #### 1. 运算符重载 
>
> ```c++
> //这个为c_name的友元函数，因为需要访问c_name对象的私有部分,而ostream始终都是当作整体来用的,所以不必是ostream的友元
> ostream & operator << (ostream & os, const c_name & obj) 
> {
> 	os << ......; //  display object contents
> 	return os;
> }
> 
> //这样的话这种些情况就不能重载了  cout << ..... << ...... << .....;
> 
> void operator << (ostream & os, const c_name & obj) 
> {
> 	os << ......; //  display object contents
> }
> 
> //交换操作数的顺序,可以将友元函数变为非友元函数:
> Time operator *(double m, const Time & t) 
> {
>     return t * m;    // 等价于 use    t.operator*(m);
> }
> ```
>
> 
>
> 



## 静态联编与动态联编 ##

> ##### 联编(binding)：
>
> > 选择执行特定函数代码块（由于C++重载等原因，任务变得相当复杂，不像c那样，每一个函数名对应一个不同的函数）
>
> 
>
> ##### 联编的分类：
>
> * **静态联编**：编译过程中进行的联编
> * **动态联编**：程序运行时**选择**正确的**虚函数**（由编译器生成执行这个任务的代码）
>
> 
>
> ##### 动态联编的要求：
>
> > * 有继承关系的类
> >
> > * 指针与引用类型的兼容性，通过指针或者引用的方式调用函数(c++不允许将一种类型的地址赋值给另一个类型的指针，也不允许一种类型的引用指向另一种类型，**但是这一规则对于继承来说是个例外**)
> > * 虚函数(**编译器对虚函数方法使用动态联编，编译器对非虚方法使用静态编译**)
>
> 
>
> ##### 指针和引用类型的兼容：
>
> > 这是一种特殊的兼容，这种一种类型的指针或者引用可以转换成另一种类型的指针或者引用**仅仅适用于有继承关系的类上**
> >
> > * 派生类转换成基类是**可以隐式**转换的同时也是**安全的**
> >
> >     ```c++
> >     class son::person{
> >     
> >     };
> >     person *p1 = nullptr;
> >     son s1;
> >     p1 = &s1;           //向上强制转换
> >     ```
> >
> > * 基类转换成派生类必须得**强制转换**，**且是不安全的**
> >
> >     ```c++
> >     class son::person{
> >     	getmoney(){} //基类没有的方法
> >     };
> >     son *s1 = nullptr;
> >     person p1
> >     s1 = &p1;           //向上强制转换
> >     s1->getmoney()      //向下转换带来不安全的操作，因为person里面没有这个getmoney()这个方法
> >     ```
> >
> >     
>
> ##### 问题 ： 既然动态联编如此之好为什么不把这个设成默认方式呢？
>
> > ##### 原因：
> >
> > * 静态联编的效率更高，动态联编需要额外的开销
> > * 派生类可能没有重写基类的方法，这样要是把动态联编设为默认的话，效率就降低了
>
> 
>
> ##### 虚函数的工作原理
>
> >
>
> ##### 有关虚函数的注意事项：
>
> > * 在基类中使用关键字`virtual`可以让该方法在**基类以及所以派生类中都是虚的**
> >
> > * 必须使用指针或者引用的方式，这样才既可以调用指针或者引用类型的派生类，实现多态
> >
> > * 构造函数**不能**是虚函数  -------->  ( 从C++之父Bjarne的回答我们应该知道C++为什么不支持构造函数是虚函数了，简单讲就是没有意义。虚函数的作用在于通过子类的指针或引用来调用父类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用)
> >
> > * 析构函数**应当**是虚函数  ---------------> **重要**
> >
> >     ```c++
> >     Person * p = new son
> >     
> >     delete p;     
> >     
> >     //如果是静态联编的话，析构函数默认用来释放Person这个实例化对象的内存，而我们通常情况下就是需要释放指向对象的内存
> >     //所以非常建议在析构函数前面加关键字virtual
> >     ```
> >
> > * 友元**不能**是虚函数    --------->（**友元函数都不是成员函数**，但是可以让友元函数使用虚成员函数来解决一些问题）
> >
> > * 没有重新定义的不应该是虚函数   -----------> (确实不应该，因为这样的方法**直接用静态联编效率更高**)
> >
> > * 重新定义隐藏方法---------->(派生类有与基类重名的函数，那么基类的这个函数将会被覆盖掉,被隐藏,子类永远也调用不了基类的这个方法，这就是重写！！！)
> >
> > * 如果基类声明被重载了，那么派生类中应该重新定义所有基类的版本，如果只定义一个的话，那么其他几个版本将会被隐藏起来



## 类的三种访问权限 ##

> ##### 类用三种访问权限：
>
> > * `public` ---------------------> 类外部还是派生类都可以访问
> > * `protected`----------------->类外部不能访问，但是派生类可以访问基类
> > * `private`--------------------->只有本类才能够访问
>
> 

### 1.protected

> * `protected成员变量` ----------------->这个不建议使用最好对数据采用私有访问控制
> * `protected成员函数`------------------>很有用能够让**派生类使用外部不能使用的内部函数**





## 几种特殊的函数

> ##### 注意
>
> > * 这四个函数要是没有初始化，系统会默认给出，当出现**指针引用这种东西时，一般需要自己写，默认的不能满足我们的需求**

### 1.构造函数

> #### 简介
>
> > 在类创建时自动调用跟析构函数是一对相反的函数，析构函数在该类完成任务后，自动调用
>
> 
>
> #### 特点
>
> * **能够重载**
>
> * **不能是虚函数**！！！！！！！！！！！！
>
> * **派生类不继承基类的构造方法**，但子类可以继承父类所有的成员变量和成员方法
>
> * **接受默认值以及接受初始化列表的方式进行初始化**，但是**只能**在构造函数中使用初始化列表的方法进行初始化
>
>     ```c++
>     class Point{
>     .......................
>         //Point(int x = 0, int y = 0) 这个是默认参数，每个函数可以使用默认参数的方式
>     	Point(int x = 0, int y = 0):x(x), y(y);    //初值化列表                
>         Point():x(0),y(0);
>     ........................
>     };
>     //调用 Point p1()    //到底调用上面那个构造函数还是下面那个构造函数呢会出现二义性
>     //    Point p2;     //到底调用上面那个构造函数还是下面那个构造函数呢会出现二义性
>     ```
>
>  #### 初值化列表
>
> * 初始化列表相当于**变量初始化**，比先定义后赋值的效率高！！！！**推特推荐初值化列表的这种写法**
>
>     ```c++
>     class Point{
>     	Point(int x = 0, int y = 0):x(x), y(y);    //初值化列表               
>         Point():x(0),y(0);
>     };
>                                     
>     ```
>
>     





### 2.析构函数

> ##### 简介
>
> 析构函数在该类完成任务后，自动调用，与构造函数正好相反









### 3.拷贝构造函数

> ##### 简介
>
> 



















# STL

## unorded_map容器 ##

### 底层原理
>**哈希表**
>
>
>
### 特性
>**key无序，key不可以重复，key不可以修改**
>
>
>
### 复杂度
>
>查询效率 : $O(1)$
>
>增删效率 : $O(1)$
>
### 常用函数
>* `.count(key)` 接受参数key在unordered_map容器检查是否含有指定的key,有返回1没有返回0
>
>
>


# 函数



## 1.memset()函数 ##

### 函数原型 ###

```c++
void *memset(void *str, int c, size_t n)
```

- **str** -- 指向要填充的内存块。str 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化
- **c** -- 要被设置的值。该值以 int 形式传递。
- **n** -- 要被设置为的字节个数

### **函数的功能** ###

- 作用是在一段内存块中(str为起始地址，结束地址为str + n)填充某个给定的值

- 注意！！！！这里的给值**以字节为单位的**！！！比如给一个int类型的数组赋值为0x3f3f3f3f，只需要填入0x3f就行，因为这是按照字节来赋值的，一个int占4个字节然后4个字节和在一起就是0x3f3f3f3f

    

### **函数的常见应用** ###

- 清零是memset(a,0,sizeof(a));
- 初始化为无穷大为memset(a,0x3f,sizeof(0x3f)); （注意一般用0x3f3f3f3f这个无穷大多一些因为一些题目的数据是1e9然后这个恰好比1e9大一些而且无穷大0x3f3f3f3f + 0x3f3f3f3f不会超过int的范围，而0x7fffffff是int类型的最大值）





# 修饰符



## 1.const 修饰符 ##

### const修饰符的说明 ###

> const 一种**提示编译器**被修饰的这些东西，只具有“**可读的特点**”，修饰符本身，并**不产生任何**实际代码**尽可能使用const，将帮助我们避免很多错误，提高程序正确率**
>



### const修饰符的用法 ###



#### 1.const修饰普通变量 ####

> const 变量指的是，此变量的值是只读的，不应该被改变。
> **注意：**在C++中，const 全局变量被用来替换一般常量宏定义，比define好使,可以让编译器帮助我们进行变量类型检查，提高正确率

```c++
const int num = 10;   //被const修饰的变量得在初始化就赋初值
    
const int x;          //编译错误：一般编译器会报错，得赋初值

num = 20             //被const修饰符修饰的变量被再次修改时,编译器会报错
```



#### 2.指向const变量的指针 ####

> 存着一个const变量的地址，不能通过改指针修改这个变量的值
>
> **注意**：虽然指针指向的值不能改变，但是指针指向的值可以改变，**编译器是通过指针类型来判断该指针所指向的类型**

```c++
const int x = 1;       
int y = 2;
const int * p = &x;       // 编译器是通过指针类型来判断该指针所指向的类型

*p = 100;                // 修改指向const类型变量的值是非法的，编译器会报错

p = &y;                  // 可以修改指针指向的地址
```



```c++
const int x_const = 100;      
int *p = (int *) &x_const;        
*p = 10000;        //修改const变量的值,编译器通过指针变量的类型来判断指向的类型
cout << *p << endl;   //这里输出的结果是100,可能会问为什么不是10000
    //原因就是编译器对const变量进行替换，类似于define,但是比define更安全
    //编译器将 const 变量直接替换为对应的内容,结果是不确定的更编译器优化等级有关
cout << x_const << endl; //这里输出的结果是10000
```





#### 3.const指针 ####

> const 指针是指，是指所指的东西不会改变，但是所指向的内容可以改变

```c++
int x = 100, y = 200;
int *const p = &x;   //初始化一个常指针
*p = y;              //这个是正确的,p的指向没有发生变化
p = &y;              //错误的常指针初始化后,不能改变指向
```





#### 4.const 变量作为函数参数 ####

> - 函数参数为普通变量，对于函数来说这个一个const 变量，函数内部不能修改这个值
>
> - 函数参数为指针，如果声明为指向const类型变量的指针话，允许让指向**const类型变量的指针或者普通变量的指针**作为参数来调用函数，如果声明为普通指针，则不允许使用**指向 const 变量的指针**作为参数调用
>
> - 原因: int * 类型会**隐式的**转换成 const int * 类型，而const int * 不会隐式的转换成int*,至于为什么是这样的想必很容易知道了，要是const int * 也能隐式的转换成 int * 那么const就没有存在的意义了
```c++
int sum1(const int* a, const int* b) {
    return *a + *b;
}
int sum2(int *a, int* b) {
    return *a + *b;
}

const int a = 1;
int b = 2;
cout << sum1(&a, &b) << endl;       //编译不报错,int * 类型会隐式的转换成const int *
//cout << sum2(&a, &b) << endl;     //编译报错,const int * 类型不会隐式的转换成int *
cout << sum2((int*)&a, &b) << endl; //编译不报错,const int * 类型强制转换成int *

```



#### 5.const 返回值 ####

> const 型的返回值，指的是函数的返回值为一个 const 变量.引用相当于常指针，而const引用相当于指向const某类型的常指针
>
> **注意：const 返回值主要应用在返回const 引用上**

```c++
const int &fun1(int& a) {
    return a;
}
int &fun2(int & a) {
    return a;
}
int x = 10;

double1(x) = 10;     //编译错误
cout << x << endl;
double2(x) = 100;    //编译没有问题
cout << x << endl;
```





#### 6.const 成员变量 ####
>- const 成员变量在类外部跟类内部都不能被修改
>
> - const 成员变量**必须被初始化**（在相关构造函数的**初始化列表中**），**初始化后，不能够被修改**
>- 静态 const 成员变量**需要在类外部单独定义并初始化（可定义在头文件）**



#### 7.const 类对象 ####


>> **简单来说const类对象不能改变任何成员变量的值同时只能调用const函数**
>
> - const类对象指的是，此类对象不应该被改变。
> - const 类对象与 const 变量并无实质不同，只在于类对象的 “改变” 定义。
> - 类对象的 “改变” 定义**：改变任何成员变量的值，调用任何非const成员函数**



#### 8.const 成员函数 ####


>创建成员函数:
>
>> ```c++
>> class point{
>> 	//省略很多东西
>> 	int getX() const;
>> }
>> int Point::getX() const{}
>> ```
>> **注意：函数声明跟定义后面必须都加const**
>> 
>>
>
>- const成员函数指的是，此函数**不应该修改this对象成员变量**（注意啊是this对象！！！！,同类非this对象也可以修改啊）。
>
>- 传给const成员函数的this指针，是**指向 const 对象 的 const 指针**
>
>- const成员函数，不能够修改任何成员变量，**除非成员变量被 mutable 修饰符修饰**。
>
>- 原因： 在成员函数调用的过程中，都有一个 this 指针被当做参数隐性地传递给成员函数（可能通过栈，也可能通过CPU寄存器）。这个this指针，指向调用这个函数的对象（这样，成员函数才能找到成员变量的地址，从而对其进行操作）。这个this指针，是个 const指针，不能修改其指向（你不希望这个对象的函数，修改了那个对象的成员变量，对吧？）。
>
>    　　传递给const成员函数的this指针，指向一个const对象。也就是说，在const成员函数内部，这个this指针是一个指向const对象的const指针。通过第二节的探讨，相信大家已经能够明白，为什么const成员函数不能修改任何成员变量了。
>
>       　　mutable 修饰符使得const函数的行为有了一些灵活性。相当于提醒编译器，这个成员变量比较特殊，就不要进行任何只读检查了。
>
>       　　我们在第二节留下了一个问题 “为什么 const 对象只能够调用const成员函数呢？”，其实是这样的。由于对象本身通过 const 修饰，那么指向这个对象的指针也就是指向const对象的const指针了。换句话说，指向这个对象的this指针就是指向const对象的const指针。一般成员函数要求的this指针（别忘了this指针也是一个参数）为：指向对象的const指针。所以此处发生了参数不匹配，无法进行调用。而 const 成员函数要求的this指针，恰恰是 指向const对象的const指针。所以依然能够调用。





# 关键字

## 1.static关键字 ##



### **函数的用法** ###

#### 1.静态局部变量（面向过程） ####

> 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量
>
> > 特点：
> >
> > - 静态局部变量在**全局数据区**分配内存
> > - 静态局部变量在程序执行到该对象的声明处时被**首次初始化（只会被初始化一次）**，即以后的函数调用不再进行初始化；
> > - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序**自动初始化为0(不同类型的0,如false，'\0'等)**
> > - 静态局部变量始终驻留在**全局数据区**，直到程序运行结束。但其作用域为**局部作用域**，当定义它的函数或语句块结束时，其作用域随之结束
> > 

```c++
#include <bits/stdc++.h>
using namespace std;
int calcu(void) {
    static int x = 1;
    x++;
    return x;
}
int main(void) {
    for(int i = 1; i <= 3; i++) {
        cout << "第" << i << "次" << "调用函数" << endl;
        cout << calcu() << endl;
        cout << "----------" << endl;
    }
    return 0;
}
```

```c++
第1次调用函数
2
----------   
第2次调用函数
3
----------   
第3次调用函数
4
----------

reason:第一次初始化为1后只会调用该函数只会就不会初始化了
```

#### 2.**静态全局变量**（面向过程） ####

> 特点：
>
> - 该变量在**全局数据区**分配内存
>
> - 未经初始化的静态全局变量会被程序**自动初始化为0(不同类型的0,如false，'\0'等)**
>
> - 静态全局变量在声明它的**整个文件都是可见的，而在文件之外**是不可见的
>
> - 静态变量都在全局数据区分配内存，包括前面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：**【代码区】【全局数据区】【堆区】【栈区】**，一般程序的由**new产生的动态数据存放在堆区**，**函数内部的自动变量存放在栈区**，**静态数据（即使是函数内部的静态局部变量）存放在全局数据区**。自动变量一般会随着函数的退出而释放空间，而**全局数据区的数据并不会因为函数的退出而释放空间**。
>
> 好处：
>
> * 静态全局变量不能被其它文件所用；
> * 其它文件中可以定义相同名字的变量，不会发生冲突
> 



#### 3.**静态函数（面向过程）** ####

> 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
>
> 特点：
>
> * 静态函数不能被其它文件所用
> * 其它文件中可以定义相同名字的函数，不会发生冲突





#### 4.**静态成员变量（面向对象）** ####

> 在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。
>
> 特点：
>
> * 静态数据成员在**全局数据区**分配内存,在**没有类的实例存在**时，静态成员变量就已经存在,静态成员变量只分配一次内存,**并且由本类的所有对象共享**,不占用对象的内存（所以**sizeof 运算符不会计算 静态成员变量**）
>
> * static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量**必须初始化**，而且**只能在类体外进行**
>
>     ```c++
>     class myclass {
>           ………………
>           ………………
>           private:
>           static int x;
>     };
>     //静态成员变量**必须初始化**，而且**只能在类体外进行**
>     int myclass::x = 100;
>     ```
>
> * **静态成员变量**如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。
>
> * static 成员变量**不随对象的创建而分配内存**，也**不随对象的销毁而释放内存**。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存
>
> * **访问修饰符 private、protected、public等跟static不矛盾**，static关键字让所有对象可共享，而访问修饰符决定访问权限，得有权限才可以通过对象取访问，要理解
>
> * 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名（前提是有**静态数据成员的访问权限**）
>
> * 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问
>
> 
>
> > 常用情况：
> >
> > 如果想在同类的**多个对象之间实现数据共享，又不要用全局变量**，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候
>
> 
>
> 好处：
>
> * 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，**节省存储空间**。
> * 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了
>
> 同全局变量相比，使用静态数据成员有两个优势 
>
> * 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能
> * **可以实现信息隐藏。静态成员变量可以是private成员**，而全局变量不能



#### 5.**静态成员函数（面向对象）** ####

> 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象与普通函数相比，静态成员函数属于类本身，而**不作用于对象，因此它不具有this指针**。正因为**它没有指向某一个对象**，所以它**无法访问属于类对象的非静态成员变量和非静态成员函数**，它**只能调用其余的静态成员函数和静态成员变量**
>
> 
>
> 特点：
>
> * 静态成员函数**（仅）**可以访问**静态成员变量、静态成员函数**，静态成员函数**不能访问非静态成员函数和非静态成员变量**，非静态成员函数可以**任意地访问**静态成员函数和静态数据成员；
> * 由于**没有this指针的额外开销**，静态成员函数与类的全局函数相比速度上会稍快
> * 调用静态成员函数方式一：通过**成员访问操作符(.)和(->)**，也即通过类对象或指向类对象的指针调用静态成员函数。
> * 调用静态成员函数方式二：直接**通过类来调用静态成员函数**。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。
> 



## 2.inline关键字

> #### 概述
>
> `inline`功能类似于`define`，它是对编译器的一种建议，函数过于复杂的话编译器也实现不了,毕竟只是给编译器的一种建议而已

# 指针



## 1.void指针(void *)

> `void*`是一种特殊的指针类型，可用于存放**任意**对象的地址,变量不能声明为void类型
>
> > 先介绍一下void：
> >
> > * 如果函数没有返回值，那么应声明为 `void` 类型；
> > * 如果函数无参数，那么应声明其参数为 `void`；（常省略）
> > * 如果函数的参数或返回值可以是任意类型指针，那么应声明其类型为 `void*` 
> > 
>
> 特点：
>
> * **任何类型的指针都可以直接赋值给void指针， 且无需进行强制类型转换**。
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>     p = &x;		//正确，p是可以存放任意类型的指针   
>     p = &y;		//正确，p是可以存放任意类型的指针
>     p = &z;		//正确，p是可以存放任意类型的指针
>     ```
>
> 
>
> * **void指针并不能无需类型转换直接赋值给其他类型**
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>     int* w;
>     double* u;
>     long* q;
>     
>     p = &x;
>     w = (int*)p;            //必循强制转换
>     cout << *w << endl;
>     
>     p = &y;
>     u = (double*)p;			//必循强制转换
>     cout << *u << endl;
>     
>     p = &z;
>     q = (long*)p;			//必循强制转换
>     cout << *q << endl;
>     ```
>
> * **void指针只有强制类型转换后才可以正常对其操作**
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>                                                                                                                                                                                                                                                         
>     p = &x;
>     cout << *(int*)p << endl;        //必须强制转换
>                                                                                                                                                                                                                                                         
>     p = &y;
>     cout << *(double*)p << endl;	//必须强制转换
>                                                                                                                                                                                                                                                         
>     p = &z;
>     cout << *(long*)p << endl;		//必须强制转换	
>     return 0;
>     ```
>







# 预处理



## 1.条件编译 ##

> # ifndef/define/endif
>
>
> > 作用：
> > * **防止头文件被重复包含和编译。**头文件重复包含会增加程序大小，增加编译时间
> >
> >     ```c++
> >     未加条件编译
> >     //test.cpp
> >     #include "file1.h"
> >     #include "file2.h"
> >     int main(void) {
> >      myprint();
> >      return 0;
> >     }
> >                                                                                                                                                                                                                                             
> >     //file1.h
> >     #include <iostream>
> >                                                                                                                                                                                                                                             
> >     //file2.h
> >     #include "file1.h"
> >     void myprint() {
> >         cout << "hello world" << endl; 
> >     }
> >                                                                                                                                                                                                                                             
> >     这里编译时成了这样的了
> >     #include <iostream>
> >     #include "file2.h" 
> >     #include <iostream>
> >     增加条件编译之后变成如下了
> >     ```
> >
> >     ```c++
> >     加条件编译之后
> >     //test.cpp
> >     #include "file1.h"
> >     #include "file2.h"
> >     int main(void) {
> >      myprint();
> >      return 0;
> >     }
> >                                                                                                                                                                                                                                             
> >     //file1.h
> >     #ifndef FILE1_H
> >     #define FILE1_H
> >                                                                                                                                                                                                                                             
> >     #include <iostream>
> >                                                                                                                                                                                                                                             
> >     #endif
> >                                                                                                                                                                                                                                             
> >     //file2.h
> >     #ifndef FILE2_H
> >     #define FILE2_H
> >                                                                                                                                                                                                                                             
> >     #include "file1.h"
> >     void myprint() {
> >         cout << "hello world" << endl; 
> >     }
> >                                                                                                                                                                                                                                             
> >     #endif
> >     ```
> >
> >     
> >
> > * **防止无限循环编译**
> >
> >     ```c++
> >     没有条件编译指令
> >     //file1.h
> >     #include "file2.h"
> >                                                                                                                                                                                                                                             
> >     //file2.h
> >     #include "file1.h"
> >                                                                                                                                                                                                                                             
> >      会出现无限编译的情况
> >     ```
> >
> >     ```c++
> >     解决方法
> >     //file1.h
> >     #ifndef FILE1_H
> >     #define FILE1_H
> >                                                                                                                                                                                                                                             
> >     #include "file2.h"
> >                                                                                                                                                                                                                                             
> >     #endif
> >     
> >     
> >     //file2.h
> >     #ifndef FILE2_H
> >     #define FILE2_H
> >                                                                                                                                                                                                                                             
> >     #include "file1.h"
> >                                                                                                                                                                                                                                             
> >     #endif
> >     ```
> >
> > * **防止全局变量的重复定义**
> >
> >     ```c++
> >     通过上面的例子应该很容易理解这种情况了
> >     ```
> >
> >     





# 运算符

## 1. i++跟++i

> 区别：
>
> * `i++`是先对i进行操作再递增i,而`++i`是先递增再对i进行操作  ----------------------->  (这个区别是我已经掌握的)
>
> * 第二个区别就是：`i++` 不能作为左值，而`++i`可以。             ----------------------->  (这个区别是我没有掌握的)
>
>     ```c++
>     int i = 10;
>                                                                                                                 
>     (i++) = 100;   //错误,i++不能作为左值
>                                                                                                                 
>     (++i) = 100;   //正确，++i可以作为左值
>     ```
>
>     
>
>     
>
>     ig 







# 其他



## namespace(命名空间)



#### 命名空间的概念

 > * c++命名空间将全局作用域分成了不同部分
 > * 不能命名空间的标识符可以同名而不会发生冲突
 > * 命名空间可以嵌套
 > * **全局作用域也叫默认命名空间**



### namespace的使用

> | 使用整个命名空间：`using namespace name`;    |
> | :------------------------------------------- |
> | 使用命名空间中的变量：`using name::variable` |
> | **使用默认命名空间中的变量**: `::variable`   |

> ```c++
> namespace std
> {
>   ...............
> }
> ```
>
> 
>
> #### 第一种使用方式(使用namespace关键字)
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> int main(void)
> {
>     cout <<.........;
> }
> ```
>
> 
>
> ####  第二种使用方式(使用声明)
>
> ```c++
> #include <bits/stdc++.h>
> using std::cout
> int main(void)
> {
>     std::cin >> .........;
>     cout << ........;
> }
> ```
>
> 
>
> #### 第三种使用方式
>
> ```c++
> #include <bits/stdc++.h>
> int main(void)
> {
> 	std::cin >> ........;
> 	std::cout << .......;
> }
> ```
>
> 





# 编写c++程序的感悟

> #### 1.类成员变量一般使用private访问权限
>
> #### 2. 函数参数尽量pass by the reference而不要pass by the value若不需要改变引用的值就加个const
>
> #### 3. 函数返回值也是如此尽量return by the reference而不要return by the value,除非有必须return by the value的情况
>
> #### 4. 尽量用构造函数初值列表，效率高
>
> #### 5.没有改变this类成员数据需求的函数都用const，要不然，创建一个const对象然后调用该函数，因为该函数是非const然后就会出错
>
> 
>
> 



