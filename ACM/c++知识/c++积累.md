# c++函数



## 1.memset()函数 ##

### 函数原型 ###

```c++
void *memset(void *str, int c, size_t n)
```

- **str** -- 指向要填充的内存块。str 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化
- **c** -- 要被设置的值。该值以 int 形式传递。
- **n** -- 要被设置为的字节个数

### **函数的功能** ###

- 作用是在一段内存块中(str为起始地址，结束地址为str + n)填充某个给定的值

- 注意！！！！这里的给值**以字节为单位的**！！！比如给一个int类型的数组赋值为0x3f3f3f3f，只需要填入0x3f就行，因为这是按照字节来赋值的，一个int占4个字节然后4个字节和在一起就是0x3f3f3f3f

    

### **函数的常见应用** ###

- 清零是memset(a,0,sizeof(a));
- 初始化为无穷大为memset(a,0x3f,sizeof(0x3f)); （注意一般用0x3f3f3f3f这个无穷大多一些因为一些题目的数据是1e9然后这个恰好比1e9大一些而且无穷大0x3f3f3f3f + 0x3f3f3f3f不会超过int的范围，而0x7fffffff是int类型的最大值）





# 修饰符



## 1.const 修饰符 ##

### const修饰符的说明 ###

> const 一种**提示编译器**被修饰的这些东西，只具有“**可读的特点**”，修饰符本身，并**不产生任何**实际代码**尽可能使用const，将帮助我们避免很多错误，提高程序正确率**
>



### const修饰符的用法 ###



#### 1.const修饰普通变量 ####

> const 变量指的是，此变量的值是只读的，不应该被改变。
> **注意：**在C++中，const 全局变量被用来替换一般常量宏定义，比define好使,可以让编译器帮助我们进行变量类型检查，提高正确率

```c++
const int num = 10;   //被const修饰的变量得在初始化就赋初值
    
const int x;          //编译错误：一般编译器会报错，得赋初值

num = 20             //被const修饰符修饰的变量被再次修改时,编译器会报错
```



#### 2.指向const变量的指针 ####

> 存着一个const变量的地址，不能通过改指针修改这个变量的值
>
> **注意**：虽然指针指向的值不能改变，但是指针指向的值可以改变，**编译器是通过指针类型来判断该指针所指向的类型**

```c++
const int x = 1;       
int y = 2;
const int * p = &x;       // 编译器是通过指针类型来判断该指针所指向的类型

*p = 100;                // 修改指向const类型变量的值是非法的，编译器会报错

p = &y;                  // 可以修改指针指向的地址
```



```c++
const int x_const = 100;      
int *p = (int *) &x_const;        
*p = 10000;        //修改const变量的值,编译器通过指针变量的类型来判断指向的类型
cout << *p << endl;   //这里输出的结果是100,可能会问为什么不是10000
    //原因就是编译器对const变量进行替换，类似于define,但是比define更安全
    //编译器将 const 变量直接替换为对应的内容,结果是不确定的更编译器优化等级有关
cout << x_const << endl; //这里输出的结果是10000
```





#### 3.const指针 ####

> const 指针是指，是指所指的东西不会改变，但是所指向的内容可以改变

```c++
int x = 100, y = 200;
int *const p = &x;   //初始化一个常指针
*p = y;              //这个是正确的,p的指向没有发生变化
p = &y;              //错误的常指针初始化后,不能改变指向
```





#### 4.const 变量作为函数参数 ####

> - 函数参数为普通变量，对于函数来说这个一个const 变量，函数内部不能修改这个值
>
> - 函数参数为指针，如果声明为指向const类型变量的指针话，允许让指向**const类型变量的指针或者普通变量的指针**作为参数来调用函数，如果声明为普通指针，则不允许使用**指向 const 变量的指针**作为参数调用
>
> - 原因: int * 类型会**隐式的**转换成 const int * 类型，而const int * 不会隐式的转换成int*,至于为什么是这样的想必很容易知道了，要是const int * 也能隐式的转换成 int * 那么const就没有存在的意义了
```c++
int sum1(const int* a, const int* b) {
    return *a + *b;
}
int sum2(int *a, int* b) {
    return *a + *b;
}

const int a = 1;
int b = 2;
cout << sum1(&a, &b) << endl;       //编译不报错,int * 类型会隐式的转换成const int *
//cout << sum2(&a, &b) << endl;     //编译报错,const int * 类型不会隐式的转换成int *
cout << sum2((int*)&a, &b) << endl; //编译不报错,const int * 类型强制转换成int *

```



#### 5.const 返回值 ####

> const 型的返回值，指的是函数的返回值为一个 const 变量.引用相当于常指针，而const引用相当于指向const某类型的常指针
>
> **注意：const 返回值主要应用在返回const 引用上**

```c++
const int &fun1(int& a) {
    return a;
}
int &fun2(int & a) {
    return a;
}
int x = 10;

double1(x) = 10;     //编译错误
cout << x << endl;
double2(x) = 100;    //编译没有问题
cout << x << endl;
```





#### 6.const 成员变量 ####

> - const 成员变量在类外部跟类内部都不能被修改
>
> - const 成员变量**必须被初始化**（在相关构造函数的**初始化列表中**），**初始化后，不能够被修改**
> - 静态 const 成员变量**需要在类外部单独定义并初始化（可定义在头文件）**



#### 7.const 类对象 ####

> - const类对象指的是，此类对象不应该被改变。
>
> - const 类对象与 const 变量并无实质不同，只在于类对象的 “改变” 定义。
> - 类对象的 “改变” 定义**：改变任何成员变量的值，调用任何非const成员函数**



#### 8.const 成员函数 ####

> - const成员函数指的是，此函数不应该修改任何成员变量。
>
> - 传给const成员函数的this指针，是**指向 const 对象 的 const 指针**
>
> - const成员函数，不能够修改任何成员变量，**除非成员变量被 mutable 修饰符修饰**。
>
> - 原因： 在成员函数调用的过程中，都有一个 this 指针被当做参数隐性地传递给成员函数（可能通过栈，也可能通过CPU寄存器）。这个this指针，指向调用这个函数的对象（这样，成员函数才能找到成员变量的地址，从而对其进行操作）。这个this指针，是个 const指针，不能修改其指向（你不希望这个对象的函数，修改了那个对象的成员变量，对吧？）。
>
>     　　传递给const成员函数的this指针，指向一个const对象。也就是说，在const成员函数内部，这个this指针是一个指向const对象的const指针。通过第二节的探讨，相信大家已经能够明白，为什么const成员函数不能修改任何成员变量了。
>
>     　　mutable 修饰符使得const函数的行为有了一些灵活性。相当于提醒编译器，这个成员变量比较特殊，就不要进行任何只读检查了。
>
>     　　我们在第二节留下了一个问题 “为什么 const 对象只能够调用const成员函数呢？”，其实是这样的。由于对象本身通过 const 修饰，那么指向这个对象的指针也就是指向const对象的const指针了。换句话说，指向这个对象的this指针就是指向const对象的const指针。一般成员函数要求的this指针（别忘了this指针也是一个参数）为：指向对象的const指针。所以此处发生了参数不匹配，无法进行调用。而 const 成员函数要求的this指针，恰恰是 指向const对象的const指针。所以依然能够调用。

