# oop特性



## 运算符重载 ##

> #### 运算符重载
>
> 类似于函数的多态，但是这个并不是**函数重载或者函数多态**，**运算符重载是多态的一种形式**，编译器通过操作数的数目和类型决定使用哪种符号的定义，重载运算符让代码看起来更加自然
>
> > ##### 运算符重载的例子
> >
> > c++中很多运算符都被重载过举个例子：我们用的cout `<<`，是重载了`<<`运算符
> >
> > **cout**是一个**ostream类**的对象，它有一个成员运算符函数operator<<,平时使用时我们能够接受不同类型的数据，如整型、浮点型、字符串甚至指针，这是因为标准库的设计者们早已经为我们定制了iostream::operator<<对于各种C++**基本数据类型的重载版本**
> >
> > > ##### 注意：iostream库定义了以下三个标准流对象
> > >
> > > * `cin `：表示标准输入(standard input)的istream类对象。cin使我们可以从设备读入数据。
> > > * `cout`：表示标准输出(standard output)的ostream类对象。cout使我们可以向设备输出或者写数据。
> > > * `cerr`：表示标准错误(standard error)的osttream类对象。cerr是导出程序错误消息的地方，它只能允许向屏幕设备写数据
> >
> > ```c++
> > #include <bits/stdc++.h>
> > using namespace std;
> > int main(void) {
> >     cout.operator << (12345);
> >     cout.operator << (endl);
> >     return 0;
> > }
> > ```
> >
> > 
>
> ####  运算符重载的**限制**:
>
> * 必须是存在的运算符，不能虚构一个运算符号
>
> * 使用运算符不能违反运算符原来运算符的规则，已经不能破坏优先级
>
> * 重载后的运算符必须至少有一个操作位数是用户自定义的，这将防止用户为标准类型重在运算符
>
> * **某些运算符是不能重载的**      （例如：`sizeof运算符`，`.成员运算符`，`作用域解析运算符::`
>
> * 大多数运算符都可以通过成员函数或者非成员函数的进行重载，但是下面四种运算符**只能通过成员函数进行承载**（常见的就是这四种）
>
>     `=` 赋值运算符
>
>     `()`函数调用运算符
>
>     `[]`下标运算符
>
>     `->`通过指针访问类成员的运算符
>
> ####  重载运算符的两种方法：
>
> * 通过成员函数进行重载
>
>     ```c++
>     class Time{
>     	//省略很多东西
>     	Time operator+ (const Time& t) constl  //member version
>     };
>     ```
>
> * 通过非成员函数进行重载(**基本上都要用到友元函数**，因为只有这样才能访问它的私有部分数据)
>
>     ```c++
>     class Time{
>     	//省略很多东西
>         friend Time operator + (const Time& t1, const Time& t2);  //友元非成员函数
>     };
>     Time operator + (const Time& t1, const Time& t2) {
>     
>     }
>     ```
>
> 
>
> > ##### 注意：
> >
> > * 重载运算符函数的参数个数与运算符的操作位数有关，比如若是定义 `&ostream operator << (const T& t1, const T& t2)`，这个若是非成员函数版本则是对的，要是是成员函数版本就错了因为<<接受两个操作对象，这样的话就三个了错误
> > * 非成员函数版本的重载运算符函数所需的**形参数目与运算符使用的操作数相同**；而成员版本所需的参数数目少一个，因为其中一个操作数是被隐式地传递的调用对象
> > * 定义运算符时，必须选择其中一种格式，避免两种格式混用，因为这两种格式都与同一个表达式匹配，**同时定义这两种格式将被视为二义性错误，导致编译错误**



### 1.成员函数运算符重载

> * 通过成员函数进行重载
>
>     ```c++
>     //mytime.h
>     #ifndef MYTIME_H_
>     #define MYTIME_H_
>     #include <iostream>
>                         
>     class Time{
>         private:
>             int hours;
>             int minutes;
>         public:
>             Time();
>             Time(int h, int m);
>             void AddMin(int m);
>             void Addhr(int h);
>             Time operator+ (const Time& t) const;      //通过成员函数进行重载
>             Time operator- (const Time& t) const;	   //通过成员函数进行重载
>             Time operator* (const double& n) const;	   //通过成员函数进行重载		
>             friend Time operator *(const double& n, const Time& t) {return t * n;} //通过非成员函数进行重载
>             friend std::ostream& operator <<(std::ostream& os, const Time& t);	   //通过非成员函数进行重载
>     };
>                         
>     #endif
>     ```
>
>     



### 2.非成员函数运算符重载

> * 通过非成员函数进行重载(**基本上都要用到友元函数**，因为只有这样才能访问它的私有部分数据)
>
>     ```c++
>     //mytime.h
>     #ifndef MYTIME_H_
>     #define MYTIME_H_
>     #include <iostream>
>                         
>     class Time{
>         private:
>             int hours;
>             int minutes;
>         public:
>             Time();
>             Time(int h, int m);
>             void AddMin(int m);
>             void Addhr(int h);
>             Time operator+ (const Time& t) const;      //通过成员函数进行重载
>             Time operator- (const Time& t) const;	   //通过成员函数进行重载
>             Time operator* (const double& n) const;	   //通过成员函数进行重载		
>             friend Time operator *(const double& n, const Time& t) {return t * n;} //通过非成员函数进行重载
>             friend std::ostream& operator <<(std::ostream& os, const Time& t);	   //通过非成员函数进行重载
>     };
>                         
>     #endif
>     ```
>
>     



## 友元 ##

> `友元`：c++**控制对类私有部分的访问**，通常情况下提供了共有方法唯一的访问途径，但这个有时候不太方便，c++提供了**另一种形式的访问：`友元`**
>
> 友元的分类：
>
> * **友元非成员函数**
> * **友元成员函数**
> * **友元类**



### 1.友元函数 

> `友元函数`：赋予与该类的成员函数相同的访问权限，类的友元函数是**非成员函数**，但是其**访问权限与成员函数相同**
>
> 创建友元函数: 
>
> ```c++
> class Time{
> 	//省略很多东西
> 
> // 1.只有类声明中的原型中才能用friend关键字，除非函数定义也是原型，否则不能在函数定义中使用friend关键字
> 	friend Time operator * (double m, const Time& t);   
> };
> 
> //2.不能在这里使用关键字friend,同时不需要Time::限定符，因为它不属于成员函数
> Time operator * (double m, const Time& t) {
> 
> }
> ```
>
> > **注意事项：**
> >
> > * 只有类声明中的原型中**才能用friend关键字**，除非函数定义也是原型，否则不能在函数定义中使用friend关键字
> > * **不需要 类名::限定符**，因为它不属于成员函数
>
> ### 应用：
>
> #### 1. 运算符重载 
>
> ```c++
> //这个为c_name的友元函数，因为需要访问c_name对象的私有部分,而ostream始终都是当作整体来用的,所以不必是ostream的友元
> ostream & operator << (ostream & os, const c_name & obj) 
> {
> 	os << ......; //  display object contents
> 	return os;
> }
> 
> //这样的话这种些情况就不能重载了  cout << ..... << ...... << .....;
> 
> void operator << (ostream & os, const c_name & obj) 
> {
> 	os << ......; //  display object contents
> }
> 
> //交换操作数的顺序,可以将友元函数变为非友元函数:
> Time operator *(double m, const Time & t) 
> {
>     return t * m;    // 等价于 use    t.operator*(m);
> }
> ```
>
> 
>
> 





# STL

## unorded_map容器 ##

### 底层原理
>**哈希表**
>
>
>
### 特性
>**key无序，key不可以重复，key不可以修改**
>
>
>
### 复杂度
>
>查询效率 : $O(1)$
>
>增删效率 : $O(1)$
>
### 常用函数
>* `.count(key)` 接受参数key在unordered_map容器检查是否含有指定的key,有返回1没有返回0
>
>
>


# 函数



## 1.memset()函数 ##

### 函数原型 ###

```c++
void *memset(void *str, int c, size_t n)
```

- **str** -- 指向要填充的内存块。str 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化
- **c** -- 要被设置的值。该值以 int 形式传递。
- **n** -- 要被设置为的字节个数

### **函数的功能** ###

- 作用是在一段内存块中(str为起始地址，结束地址为str + n)填充某个给定的值

- 注意！！！！这里的给值**以字节为单位的**！！！比如给一个int类型的数组赋值为0x3f3f3f3f，只需要填入0x3f就行，因为这是按照字节来赋值的，一个int占4个字节然后4个字节和在一起就是0x3f3f3f3f

    

### **函数的常见应用** ###

- 清零是memset(a,0,sizeof(a));
- 初始化为无穷大为memset(a,0x3f,sizeof(0x3f)); （注意一般用0x3f3f3f3f这个无穷大多一些因为一些题目的数据是1e9然后这个恰好比1e9大一些而且无穷大0x3f3f3f3f + 0x3f3f3f3f不会超过int的范围，而0x7fffffff是int类型的最大值）





# 修饰符



## 1.const 修饰符 ##

### const修饰符的说明 ###

> const 一种**提示编译器**被修饰的这些东西，只具有“**可读的特点**”，修饰符本身，并**不产生任何**实际代码**尽可能使用const，将帮助我们避免很多错误，提高程序正确率**
>



### const修饰符的用法 ###



#### 1.const修饰普通变量 ####

> const 变量指的是，此变量的值是只读的，不应该被改变。
> **注意：**在C++中，const 全局变量被用来替换一般常量宏定义，比define好使,可以让编译器帮助我们进行变量类型检查，提高正确率

```c++
const int num = 10;   //被const修饰的变量得在初始化就赋初值
    
const int x;          //编译错误：一般编译器会报错，得赋初值

num = 20             //被const修饰符修饰的变量被再次修改时,编译器会报错
```



#### 2.指向const变量的指针 ####

> 存着一个const变量的地址，不能通过改指针修改这个变量的值
>
> **注意**：虽然指针指向的值不能改变，但是指针指向的值可以改变，**编译器是通过指针类型来判断该指针所指向的类型**

```c++
const int x = 1;       
int y = 2;
const int * p = &x;       // 编译器是通过指针类型来判断该指针所指向的类型

*p = 100;                // 修改指向const类型变量的值是非法的，编译器会报错

p = &y;                  // 可以修改指针指向的地址
```



```c++
const int x_const = 100;      
int *p = (int *) &x_const;        
*p = 10000;        //修改const变量的值,编译器通过指针变量的类型来判断指向的类型
cout << *p << endl;   //这里输出的结果是100,可能会问为什么不是10000
    //原因就是编译器对const变量进行替换，类似于define,但是比define更安全
    //编译器将 const 变量直接替换为对应的内容,结果是不确定的更编译器优化等级有关
cout << x_const << endl; //这里输出的结果是10000
```





#### 3.const指针 ####

> const 指针是指，是指所指的东西不会改变，但是所指向的内容可以改变

```c++
int x = 100, y = 200;
int *const p = &x;   //初始化一个常指针
*p = y;              //这个是正确的,p的指向没有发生变化
p = &y;              //错误的常指针初始化后,不能改变指向
```





#### 4.const 变量作为函数参数 ####

> - 函数参数为普通变量，对于函数来说这个一个const 变量，函数内部不能修改这个值
>
> - 函数参数为指针，如果声明为指向const类型变量的指针话，允许让指向**const类型变量的指针或者普通变量的指针**作为参数来调用函数，如果声明为普通指针，则不允许使用**指向 const 变量的指针**作为参数调用
>
> - 原因: int * 类型会**隐式的**转换成 const int * 类型，而const int * 不会隐式的转换成int*,至于为什么是这样的想必很容易知道了，要是const int * 也能隐式的转换成 int * 那么const就没有存在的意义了
```c++
int sum1(const int* a, const int* b) {
    return *a + *b;
}
int sum2(int *a, int* b) {
    return *a + *b;
}

const int a = 1;
int b = 2;
cout << sum1(&a, &b) << endl;       //编译不报错,int * 类型会隐式的转换成const int *
//cout << sum2(&a, &b) << endl;     //编译报错,const int * 类型不会隐式的转换成int *
cout << sum2((int*)&a, &b) << endl; //编译不报错,const int * 类型强制转换成int *

```



#### 5.const 返回值 ####

> const 型的返回值，指的是函数的返回值为一个 const 变量.引用相当于常指针，而const引用相当于指向const某类型的常指针
>
> **注意：const 返回值主要应用在返回const 引用上**

```c++
const int &fun1(int& a) {
    return a;
}
int &fun2(int & a) {
    return a;
}
int x = 10;

double1(x) = 10;     //编译错误
cout << x << endl;
double2(x) = 100;    //编译没有问题
cout << x << endl;
```





#### 6.const 成员变量 ####

> - const 成员变量在类外部跟类内部都不能被修改
>
> - const 成员变量**必须被初始化**（在相关构造函数的**初始化列表中**），**初始化后，不能够被修改**
> - 静态 const 成员变量**需要在类外部单独定义并初始化（可定义在头文件）**



#### 7.const 类对象 ####

> - const类对象指的是，此类对象不应该被改变。
>
> - const 类对象与 const 变量并无实质不同，只在于类对象的 “改变” 定义。
> - 类对象的 “改变” 定义**：改变任何成员变量的值，调用任何非const成员函数**



#### 8.const 成员函数 ####


>创建成员函数:
>
>> ```c++
>> class point{
>> 	//省略很多东西
>> 	int getX() const;
>> }
>> int Point::getX() const{}
>> ```
>> **注意：函数声明跟定义后面必须都加const**
>> 
>>
>
>- const成员函数指的是，此函数**不应该修改this对象成员变量**（注意啊是this对象！！！！,同类非this对象也可以修改啊）。
>
>- 传给const成员函数的this指针，是**指向 const 对象 的 const 指针**
>
>- const成员函数，不能够修改任何成员变量，**除非成员变量被 mutable 修饰符修饰**。
>
>- 原因： 在成员函数调用的过程中，都有一个 this 指针被当做参数隐性地传递给成员函数（可能通过栈，也可能通过CPU寄存器）。这个this指针，指向调用这个函数的对象（这样，成员函数才能找到成员变量的地址，从而对其进行操作）。这个this指针，是个 const指针，不能修改其指向（你不希望这个对象的函数，修改了那个对象的成员变量，对吧？）。
>
>    　　传递给const成员函数的this指针，指向一个const对象。也就是说，在const成员函数内部，这个this指针是一个指向const对象的const指针。通过第二节的探讨，相信大家已经能够明白，为什么const成员函数不能修改任何成员变量了。
>
>       　　mutable 修饰符使得const函数的行为有了一些灵活性。相当于提醒编译器，这个成员变量比较特殊，就不要进行任何只读检查了。
>
>       　　我们在第二节留下了一个问题 “为什么 const 对象只能够调用const成员函数呢？”，其实是这样的。由于对象本身通过 const 修饰，那么指向这个对象的指针也就是指向const对象的const指针了。换句话说，指向这个对象的this指针就是指向const对象的const指针。一般成员函数要求的this指针（别忘了this指针也是一个参数）为：指向对象的const指针。所以此处发生了参数不匹配，无法进行调用。而 const 成员函数要求的this指针，恰恰是 指向const对象的const指针。所以依然能够调用。





# 关键字

## 1.static关键字 ##



### **函数的用法** ###

#### 1.静态局部变量（面向过程） ####

> 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量
>
> > 特点：
> >
> > - 静态局部变量在**全局数据区**分配内存
> > - 静态局部变量在程序执行到该对象的声明处时被**首次初始化（只会被初始化一次）**，即以后的函数调用不再进行初始化；
> > - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序**自动初始化为0(不同类型的0,如false，'\0'等)**
> > - 静态局部变量始终驻留在**全局数据区**，直到程序运行结束。但其作用域为**局部作用域**，当定义它的函数或语句块结束时，其作用域随之结束
> > 

```c++
#include <bits/stdc++.h>
using namespace std;
int calcu(void) {
    static int x = 1;
    x++;
    return x;
}
int main(void) {
    for(int i = 1; i <= 3; i++) {
        cout << "第" << i << "次" << "调用函数" << endl;
        cout << calcu() << endl;
        cout << "----------" << endl;
    }
    return 0;
}
```

```c++
第1次调用函数
2
----------   
第2次调用函数
3
----------   
第3次调用函数
4
----------

reason:第一次初始化为1后只会调用该函数只会就不会初始化了
```

#### 2.**静态全局变量**（面向过程） ####

> 特点：
>
> - 该变量在**全局数据区**分配内存
>
> - 未经初始化的静态全局变量会被程序**自动初始化为0(不同类型的0,如false，'\0'等)**
>
> - 静态全局变量在声明它的**整个文件都是可见的，而在文件之外**是不可见的
>
> - 静态变量都在全局数据区分配内存，包括前面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：**【代码区】【全局数据区】【堆区】【栈区】**，一般程序的由**new产生的动态数据存放在堆区**，**函数内部的自动变量存放在栈区**，**静态数据（即使是函数内部的静态局部变量）存放在全局数据区**。自动变量一般会随着函数的退出而释放空间，而**全局数据区的数据并不会因为函数的退出而释放空间**。
>
> 好处：
>
> * 静态全局变量不能被其它文件所用；
> * 其它文件中可以定义相同名字的变量，不会发生冲突
> 



#### 3.**静态函数（面向过程）** ####

> 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
>
> 特点：
>
> * 静态函数不能被其它文件所用
> * 其它文件中可以定义相同名字的函数，不会发生冲突





#### 4.**静态成员变量（面向对象）** ####

> 在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。
>
> 特点：
>
> * 静态数据成员在**全局数据区**分配内存,在**没有类的实例存在**时，静态成员变量就已经存在,静态成员变量只分配一次内存,**并且由本类的所有对象共享**,不占用对象的内存（所以**sizeof 运算符不会计算 静态成员变量**）
>
> * static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量**必须初始化**，而且**只能在类体外进行**
>
>     ```c++
>     class myclass {
>           ………………
>           ………………
>           private:
>           static int x;
>     };
>     //静态成员变量**必须初始化**，而且**只能在类体外进行**
>     int myclass::x = 100;
>     ```
>
> * **静态成员变量**如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。
>
> * static 成员变量**不随对象的创建而分配内存**，也**不随对象的销毁而释放内存**。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存
>
> * **访问修饰符 private、protected、public等跟static不矛盾**，static关键字让所有对象可共享，而访问修饰符决定访问权限，得有权限才可以通过对象取访问，要理解
>
> * 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名（前提是有**静态数据成员的访问权限**）
>
> * 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问
>
> 
>
> > 常用情况：
> >
> > 如果想在同类的**多个对象之间实现数据共享，又不要用全局变量**，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候
>
> 
>
> 好处：
>
> * 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，**节省存储空间**。
> * 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了
>
> 同全局变量相比，使用静态数据成员有两个优势 
>
> * 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能
> * **可以实现信息隐藏。静态成员变量可以是private成员**，而全局变量不能



#### 5.**静态成员函数（面向对象）** ####

> 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象与普通函数相比，静态成员函数属于类本身，而**不作用于对象，因此它不具有this指针**。正因为**它没有指向某一个对象**，所以它**无法访问属于类对象的非静态成员变量和非静态成员函数**，它**只能调用其余的静态成员函数和静态成员变量**
>
> 
>
> 特点：
>
> * 静态成员函数**（仅）**可以访问**静态成员变量、静态成员函数**，静态成员函数**不能访问非静态成员函数和非静态成员变量**，非静态成员函数可以**任意地访问**静态成员函数和静态数据成员；
> * 由于**没有this指针的额外开销**，静态成员函数与类的全局函数相比速度上会稍快
> * 调用静态成员函数方式一：通过**成员访问操作符(.)和(->)**，也即通过类对象或指向类对象的指针调用静态成员函数。
> * 调用静态成员函数方式二：直接**通过类来调用静态成员函数**。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。
> 



## 2.关键字 

# 指针



## 1.void指针(void *)

> `void*`是一种特殊的指针类型，可用于存放**任意**对象的地址,变量不能声明为void类型
>
> > 先介绍一下void：
> >
> > * 如果函数没有返回值，那么应声明为 `void` 类型；
> > * 如果函数无参数，那么应声明其参数为 `void`；（常省略）
> > * 如果函数的参数或返回值可以是任意类型指针，那么应声明其类型为 `void*` 
> > 
>
> 特点：
>
> * **任何类型的指针都可以直接赋值给void指针， 且无需进行强制类型转换**。
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>     p = &x;		//正确，p是可以存放任意类型的指针   
>     p = &y;		//正确，p是可以存放任意类型的指针
>     p = &z;		//正确，p是可以存放任意类型的指针
>     ```
>
> 
>
> * **void指针并不能无需类型转换直接赋值给其他类型**
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>     int* w;
>     double* u;
>     long* q;
>     
>     p = &x;
>     w = (int*)p;            //必循强制转换
>     cout << *w << endl;
>     
>     p = &y;
>     u = (double*)p;			//必循强制转换
>     cout << *u << endl;
>     
>     p = &z;
>     q = (long*)p;			//必循强制转换
>     cout << *q << endl;
>     ```
>
> * **void指针只有强制类型转换后才可以正常对其操作**
>
>     ```c++
>     void* p = NULL;
>     int x = 10;
>     double y = 20.4114;
>     long z = 1000;
>                                                                                                                                             
>     p = &x;
>     cout << *(int*)p << endl;        //必须强制转换
>                                                                                                                                             
>     p = &y;
>     cout << *(double*)p << endl;	//必须强制转换
>                                                                                                                                             
>     p = &z;
>     cout << *(long*)p << endl;		//必须强制转换	
>     return 0;
>     ```
>







# 预处理



## 1.条件编译 ##

> # ifndef/define/endif
>
>
> > 作用：
> > * **防止头文件被重复包含和编译。**头文件重复包含会增加程序大小，增加编译时间
> >
> >     ```c++
> >     未加条件编译
> >     //test.cpp
> >     #include "file1.h"
> >     #include "file2.h"
> >     int main(void) {
> >      myprint();
> >      return 0;
> >     }
> >                                                                                                                                 
> >     //file1.h
> >     #include <iostream>
> >                                                                                                                                 
> >     //file2.h
> >     #include "file1.h"
> >     void myprint() {
> >         cout << "hello world" << endl; 
> >     }
> >                                                                                                                                 
> >     这里编译时成了这样的了
> >     #include <iostream>
> >     #include "file2.h" 
> >     #include <iostream>
> >     增加条件编译之后变成如下了
> >     ```
> >
> >     ```c++
> >     加条件编译之后
> >     //test.cpp
> >     #include "file1.h"
> >     #include "file2.h"
> >     int main(void) {
> >      myprint();
> >      return 0;
> >     }
> >                                                                                                                                 
> >     //file1.h
> >     #ifndef FILE1_H
> >     #define FILE1_H
> >                                                                                                                                 
> >     #include <iostream>
> >                                                                                                                                 
> >     #endif
> >                                                                                                                                 
> >     //file2.h
> >     #ifndef FILE2_H
> >     #define FILE2_H
> >                                                                                                                                 
> >     #include "file1.h"
> >     void myprint() {
> >         cout << "hello world" << endl; 
> >     }
> >                                                                                                                                 
> >     #endif
> >     ```
> >
> >     
> >
> > * **防止无限循环编译**
> >
> >     ```c++
> >     没有条件编译指令
> >     //file1.h
> >     #include "file2.h"
> >                                                                                                                                 
> >     //file2.h
> >     #include "file1.h"
> >                                                                                                                                 
> >      会出现无限编译的情况
> >     ```
> >
> >     ```c++
> >     解决方法
> >     //file1.h
> >     #ifndef FILE1_H
> >     #define FILE1_H
> >                                                                                                                                 
> >     #include "file2.h"
> >                                                                                                                                 
> >     #endif
> >     
> >     
> >     //file2.h
> >     #ifndef FILE2_H
> >     #define FILE2_H
> >                                                                                                                                 
> >     #include "file1.h"
> >                                                                                                                                 
> >     #endif
> >     ```
> >
> > * **防止全局变量的重复定义**
> >
> >     ```c++
> >     通过上面的例子应该很容易理解这种情况了
> >     ```
> >
> >     





# 运算符

## 1. i++跟++i

> 区别：
>
> * `i++`是先对i进行操作再递增i,而`++i`是先递增再对i进行操作  ----------------------->  (这个区别是我已经掌握的)
>
> * 第二个区别就是：`i++` 不能作为左值，而`++i`可以。             ----------------------->  (这个区别是我没有掌握的)
>
>     ```c++
>     int i = 10;
>     
>     (i++) = 100;   //错误,i++不能作为左值
>     
>     (++i) = 100;   //正确，++i可以作为左值
>     ```
>
>     
>
>     
>
>     